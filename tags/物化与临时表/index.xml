<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>物化与临时表 on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/%E7%89%A9%E5%8C%96%E4%B8%8E%E4%B8%B4%E6%97%B6%E8%A1%A8/</link><description>Recent content in 物化与临时表 on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 11 Oct 2025 03:57:23 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/%E7%89%A9%E5%8C%96%E4%B8%8E%E4%B8%B4%E6%97%B6%E8%A1%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL里的子查询和CTE居然在性能上“掐架”？到底该站哪边？</title><link>https://blog.cmdragon.cn/posts/c096347d18e67b7431faacd2c4757093/</link><pubDate>Sat, 11 Oct 2025 03:57:23 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c096347d18e67b7431faacd2c4757093/</guid><description>子查询和CTE（公共表表达式）是SQL中处理复杂查询的两种常用方法。子查询嵌套在其他查询中，分为非相关子查询（独立执行）和相关子查询（依赖外部查询）。CTE通过&lt;code&gt;WITH&lt;/code&gt;子句定义，生成临时结果集，支持物化（默认生成临时表）和递归查询。CTE的优势在于多次引用时避免重复计算，但会增加I/O开销；子查询则通过优化器融合，利用索引提高性能。递归查询是CTE的独占场景，而子查询在简单逻辑和小结果集过滤时更具优势。PostgreSQL 12+支持&lt;code&gt;NOT MATERIALIZED&lt;/code&gt;选项，减少CTE的物化开销。</description></item></channel></rss>