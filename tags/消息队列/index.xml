<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>消息队列 on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><description>Recent content in 消息队列 on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 23 Aug 2025 05:07:15 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml"/><item><title>如何让FastAPI与消息队列的联姻既甜蜜又可靠？</title><link>https://blog.cmdragon.cn/posts/1bebb53f4d9d6fbd0ecbba97562c07b0/</link><pubDate>Sat, 23 Aug 2025 05:07:15 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/1bebb53f4d9d6fbd0ecbba97562c07b0/</guid><description>消息队列与FastAPI集成在分布式系统中用于解耦服务，通过异步特性支持消息事务和幂等性保障。消息事务确保数据库操作与消息发送的原子性，避免数据不一致。幂等性设计通过唯一ID和Redis校验防止消息重复处理。关键解决方案包括事务型消息、幂等令牌和全局唯一ID。常见报错如422和503，可通过校验模型、重试机制和连接池解决。依赖库包括FastAPI、SQLAlchemy、Redis和Pika。</description></item><item><title>如何在FastAPI中巧妙实现延迟队列，让任务乖乖等待？</title><link>https://blog.cmdragon.cn/posts/174450702d9e609a072a7d1aaa84750b/</link><pubDate>Fri, 22 Aug 2025 14:32:13 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/174450702d9e609a072a7d1aaa84750b/</guid><description>消息队列是分布式系统中实现异步通信的核心组件，延迟队列则允许在指定时间后投递消息，适用于定时任务和失败重试等场景。FastAPI中推荐使用Redis或RabbitMQ作为消息中间件，结合Celery或arq实现延迟队列。Redis通过Sorted Set和arq实现全异步延迟队列，RabbitMQ则利用死信队列实现延迟投递。实际应用包括电商订单超时、会议提醒、重试机制和定时报告等。常见问题如422验证错误和连接拒绝错误，需检查数据格式和连接参数。</description></item><item><title>FastAPI的死信队列处理机制：为何你的消息系统需要它？</title><link>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</link><pubDate>Thu, 21 Aug 2025 04:33:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</guid><description>死信队列（DLQ）用于处理消息系统中的失败消息，确保主业务流程不被阻塞。FastAPI结合RabbitMQ实现死信队列，通过配置死信交换机和队列，处理消息拒收、TTL过期、队列满和重试耗尽等场景。使用Pydantic验证消息格式，确保数据有效性。FastAPI消费者服务处理消息时，若失败则触发死信路由，消息最终进入死信队列。实现包括队列初始化、消息验证、异常处理和死信路由，确保系统健壮性。</description></item><item><title>BackgroundTasks 还是 RabbitMQ？你的异步任务到底该选谁？</title><link>https://blog.cmdragon.cn/posts/d26fdc150ff9dd70c7482381ff4c77c4/</link><pubDate>Thu, 07 Aug 2025 07:20:32 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/d26fdc150ff9dd70c7482381ff4c77c4/</guid><description>FastAPI 的 BackgroundTasks 适用于轻量级任务，如日志记录和邮件发送，执行时间通常小于 3 秒。对于耗时任务，如图片处理和数据分析，推荐使用 RabbitMQ 结合 Celery。RabbitMQ 提供了消息持久化、任务重试和高并发处理能力，确保任务不丢失。通过 Pydantic 模型设计任务负载，生产者将任务提交到队列，消费者异步处理任务。综合案例展示了图片水印处理系统的实现，结合 BackgroundTasks 和 RabbitMQ 的优势，提升系统性能和可靠性。</description></item><item><title>BackgroundTasks与Celery：谁才是异步任务的终极赢家？</title><link>https://blog.cmdragon.cn/posts/792cac4ce6eb96b5001da15b0d52ef83/</link><pubDate>Wed, 06 Aug 2025 00:27:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/792cac4ce6eb96b5001da15b0d52ef83/</guid><description>FastAPI的BackgroundTasks模块适用于短时任务（如邮件发送、日志写入），基于请求-响应后的异步执行机制，但不支持任务持久化和分布式处理。与Celery相比，BackgroundTasks适合处理5秒内的任务，而Celery适合长时间任务和分布式场景。消息队列的核心组件包括Broker、生产者-消费者模式和消息确认机制。混合架构可结合BackgroundTasks和Celery，分别处理快速和慢速任务。长时间任务应使用Celery，避免阻塞FastAPI事件循环。</description></item></channel></rss>