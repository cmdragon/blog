<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Options API on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/Options-API/</link><description>Recent content in Options API on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 16 Nov 2025 07:29:58 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/Options-API/index.xml" rel="self" type="application/rss+xml"/><item><title>Vue3计算属性的缓存机制与Options/Composition API用法你都了解吗</title><link>https://blog.cmdragon.cn/posts/7d2a07177c928caf0b321b44d00e8b08/</link><pubDate>Sun, 16 Nov 2025 07:29:58 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/7d2a07177c928caf0b321b44d00e8b08/</guid><description>Vue 3中的计算属性（Computed Property）依赖响应式数据动态计算，具有缓存机制，仅在依赖变化时重新计算。Options API通过&lt;code&gt;computed&lt;/code&gt;字段定义计算属性，支持函数式和&lt;code&gt;getter/setter&lt;/code&gt;形式。Composition API使用&lt;code&gt;computed&lt;/code&gt;函数，适合复杂组件逻辑，支持&lt;code&gt;getter/setter&lt;/code&gt;。两者核心区别在于语法形式和逻辑组织方式，Composition API更灵活，适合逻辑复用。计算属性常用于生成衍生值，如过滤列表或格式化数据。</description></item><item><title>为什么Vue 3的计算属性能解决模板臃肿、性能优化和双向同步三大痛点？</title><link>https://blog.cmdragon.cn/posts/372acc3d3dcd47da62c48c4cf6ad9d5c/</link><pubDate>Sun, 09 Nov 2025 07:04:22 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/372acc3d3dcd47da62c48c4cf6ad9d5c/</guid><description>计算属性（Computed）是Vue 3中用于派生状态的核心API，能够将复杂逻辑从模板中抽离，提升代码简洁性和可维护性。计算属性通过缓存机制优化性能，仅在依赖的响应式数据变化时重新计算，而方法则每次调用都会执行。可写计算属性允许通过getter和setter实现双向同步，Vue 3.4+还支持获取计算属性的之前值，用于保留历史状态。使用时应保持getter无副作用，避免直接修改计算属性值。</description></item><item><title>Vue响应式声明的API差异、底层原理与常见陷阱你都搞懂了吗</title><link>https://blog.cmdragon.cn/posts/654b9447ef1ba7ec1126a1bc26a4726d/</link><pubDate>Sat, 08 Nov 2025 06:25:19 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/654b9447ef1ba7ec1126a1bc26a4726d/</guid><description>Options API和Composition API是Vue 3中声明和操作响应式数据的两种方式。Options API通过&lt;code&gt;data&lt;/code&gt;选项声明响应式状态，Vue 3使用Proxy实现响应式，需通过&lt;code&gt;this&lt;/code&gt;访问代理对象。Composition API推荐使用&lt;code&gt;ref&lt;/code&gt;和&lt;code&gt;reactive&lt;/code&gt;，&lt;code&gt;ref&lt;/code&gt;用于包裹基本类型或对象，需通过&lt;code&gt;.value&lt;/code&gt;访问，&lt;code&gt;reactive&lt;/code&gt;用于对象类型，直接操作属性。&lt;code&gt;nextTick&lt;/code&gt;用于等待DOM更新完成。&lt;code&gt;reactive&lt;/code&gt;对象不能直接替换引用，解构会丢失响应式，需用&lt;code&gt;toRefs&lt;/code&gt;转换。</description></item></channel></rss>