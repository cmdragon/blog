<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pydantic on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/Pydantic/</link><description>Recent content in Pydantic on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 07 Sep 2025 06:55:32 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/Pydantic/index.xml" rel="self" type="application/rss+xml"/><item><title>多环境配置切换机制能否让开发与生产无缝衔接？</title><link>https://blog.cmdragon.cn/posts/533874f5700b8506d4c68781597db659/</link><pubDate>Sun, 07 Sep 2025 06:55:32 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/533874f5700b8506d4c68781597db659/</guid><description>依赖注入（Dependency Injection）是一种设计模式，通过外部提供组件所需的依赖，避免组件自行创建或管理依赖。FastAPI 的依赖注入系统基于 Python 的类型提示和 &lt;code&gt;Depends&lt;/code&gt; 函数，支持在测试或特殊场景中替换默认依赖。通过 &lt;code&gt;dependency_overrides&lt;/code&gt; 字典，可以临时覆盖依赖函数，确保函数签名一致。多环境配置中，使用 Pydantic 的 &lt;code&gt;BaseSettings&lt;/code&gt; 从环境变量或 &lt;code&gt;.env&lt;/code&gt; 文件加载配置，支持类型验证和默认值，避免手动解析。</description></item><item><title>为什么你的单元测试需要Mock数据库才能飞起来？</title><link>https://blog.cmdragon.cn/posts/6e69c0eedd8b1e5a74a148d36c85d7ce/</link><pubDate>Fri, 05 Sep 2025 05:57:12 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6e69c0eedd8b1e5a74a148d36c85d7ce/</guid><description>FastAPI 的依赖注入系统通过自动解析和管理组件依赖，提升了代码的可测试性和可维护性。Mock 对象在测试中用于替代真实依赖，如数据库连接，以避免数据污染、提高执行效率并模拟各种响应。FastAPI 的依赖系统通过 &lt;code&gt;Depends()&lt;/code&gt; 声明依赖，支持动态替换，便于测试时使用 Mock 对象。通过 &lt;code&gt;unittest.mock.patch&lt;/code&gt; 和 &lt;code&gt;app.dependency_overrides&lt;/code&gt; 可实现函数和生成器依赖的模拟，结合 Pydantic 模型确保 Mock 数据符合接口契约。分层 Mock 策略和自动化 Fixture 管理进一步优化了测试流程。</description></item><item><title>Pydantic模型验证测试：你的API数据真的安全吗？</title><link>https://blog.cmdragon.cn/posts/03b2afdf35f55dbaef631710ab6da82c/</link><pubDate>Wed, 03 Sep 2025 23:46:18 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/03b2afdf35f55dbaef631710ab6da82c/</guid><description>Pydantic在FastAPI中用于数据验证和序列化，通过Python类型注解自动解析请求体并执行验证规则，确保代码简洁安全。验证测试至关重要，可防止无效数据进入业务逻辑层，避免安全漏洞和API错误。测试环境需使用最新库版本，模型定义包括邮箱、密码和年龄的验证规则。测试脚本涵盖有效数据、边界条件和错误场景的验证。与FastAPI集成测试确保API端点验证正确。最佳实践包括覆盖所有字段、测试边界值和验证错误消息的明确性。</description></item><item><title>测试覆盖率不够高？这些技巧让你的FastAPI测试无懈可击！</title><link>https://blog.cmdragon.cn/posts/0577d0e24f48b3153b510e74d3d1a822/</link><pubDate>Tue, 02 Sep 2025 01:49:10 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/0577d0e24f48b3153b510e74d3d1a822/</guid><description>FastAPI通过TestClient工具支持单元测试，模拟HTTP请求直接调用路由处理器，验证响应状态码和数据结构。Pydantic模型确保响应数据的结构和类型符合预期，验证失败时返回422错误。测试覆盖率可通过pytest-cov工具统计，依赖项使用unittest.mock模拟。测试金字塔模型建议单元测试占70-80%，集成测试占15-20%，端到端测试占5-10%。常见错误如422、401和500，可通过检查响应模型、注入认证token和启用详细日志进行调试。</description></item><item><title>为什么你的FastAPI测试覆盖率总是低得让人想哭？</title><link>https://blog.cmdragon.cn/posts/985c18ca802f1b6da828b92e082b4d4e/</link><pubDate>Mon, 01 Sep 2025 03:56:38 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/985c18ca802f1b6da828b92e082b4d4e/</guid><description>FastAPI 开发中，测试环境和基础框架的搭建至关重要。使用 &lt;code&gt;pipenv&lt;/code&gt; 或 &lt;code&gt;poetry&lt;/code&gt; 管理虚拟环境和依赖，项目结构包括应用入口、API 路由、数据模型、数据库连接和配置文件。核心框架代码涉及 SQLAlchemy 配置、Pydantic 配置管理和 FastAPI 入口。测试覆盖率检测工具配置包括 &lt;code&gt;pytest&lt;/code&gt;、&lt;code&gt;coverage.py&lt;/code&gt; 和 &lt;code&gt;pytest-cov&lt;/code&gt;，编写测试用例并生成覆盖率报告。优化策略包括分支覆盖率测试、异步任务覆盖率和目标覆盖率报告，确保代码质量和可维护性。</description></item><item><title>FastAPI如何巧妙驾驭混合云任务调度，让异步魔力尽情释放？</title><link>https://blog.cmdragon.cn/posts/8d8e78fb048643f7ad6bd82d61e85d84/</link><pubDate>Tue, 26 Aug 2025 03:58:29 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/8d8e78fb048643f7ad6bd82d61e85d84/</guid><description>FastAPI框架利用其异步特性，结合Celery和Redis，构建了混合云任务调度方案，适用于高并发场景。方案通过Pydantic模型验证任务请求，智能路由任务至公有云或私有云节点，并实时跟踪任务状态。代码示例展示了任务提交、路由决策和状态查询的实现，特别适用于视频转码等计算密集型任务。系统自动将高负荷任务分配至公有云，普通任务则在本地处理，确保资源高效利用。</description></item><item><title>FastAPI的死信队列处理机制：为何你的消息系统需要它？</title><link>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</link><pubDate>Thu, 21 Aug 2025 04:33:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</guid><description>死信队列（DLQ）用于处理消息系统中的失败消息，确保主业务流程不被阻塞。FastAPI结合RabbitMQ实现死信队列，通过配置死信交换机和队列，处理消息拒收、TTL过期、队列满和重试耗尽等场景。使用Pydantic验证消息格式，确保数据有效性。FastAPI消费者服务处理消息时，若失败则触发死信路由，消息最终进入死信队列。实现包括队列初始化、消息验证、异常处理和死信路由，确保系统健壮性。</description></item><item><title>如何在 FastAPI 中优雅处理后台任务异常并实现智能重试？</title><link>https://blog.cmdragon.cn/posts/d5c1d2efbaf6fe4c9e13acc6be6d929a/</link><pubDate>Tue, 05 Aug 2025 03:53:28 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/d5c1d2efbaf6fe4c9e13acc6be6d929a/</guid><description>FastAPI 的 BackgroundTasks 是一种轻量级异步任务处理方案，基于 Starlette 的异步执行机制，适用于短期任务。文章深入探讨了其核心原理、异常处理和任务重试机制。通过自定义异常处理器和任务级错误捕获，可以有效处理后台任务中的异常。结合装饰器和 tenacity 库，实现了指数退避重试和异步重试策略。最后，文章通过一个支付回调通知系统的案例，展示了如何综合应用这些技术，确保任务的可靠执行。</description></item><item><title>如何在FastAPI中玩转Schema版本管理和灰度发布？</title><link>https://blog.cmdragon.cn/posts/6d9d20cd8d8528da4193f13aaf98575c/</link><pubDate>Mon, 28 Jul 2025 07:28:31 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6d9d20cd8d8528da4193f13aaf98575c/</guid><description>Schema版本管理通过Pydantic的模型继承机制实现接口兼容性，采用语义化版本控制确保v1.1.0向下兼容v1.0.0。多版本共存通过基础模型和版本路由实现，使用Union类型处理不同版本的返回数据。灰度发布通过请求头实现路由，采用金丝雀发布策略逐步扩大新版本使用范围，监控指标异常时自动回滚。典型报错如422、503和版本冲突，通过检查请求头、健康检查端点和异常处理流程解决。</description></item><item><title>SQLAlchemy ORM与GraphQL的完美邂逅，如何让数据库操作变得如此简单？</title><link>https://blog.cmdragon.cn/posts/9c8eddb46c54a20aae8fa1f51955a7b0/</link><pubDate>Tue, 22 Jul 2025 10:18:46 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/9c8eddb46c54a20aae8fa1f51955a7b0/</guid><description>SQLAlchemy ORM通过Python类与数据库表映射，实现面向对象操作数据库，典型模型包括User和Post类。FastAPI集成通过依赖注入管理数据库会话，提供GET和POST接口。GraphQL使用Strawberry定义Schema，实现类型映射和数据验证。整合应用时，通过服务层解耦GraphQL Resolver与数据库操作。常见报错包括数据验证错误和数据库连接问题，需检查请求体和配置。优化策略包括使用JOIN加载策略和实现查询深度限制。</description></item><item><title>如何在FastAPI中玩转WebSocket消息处理？</title><link>https://blog.cmdragon.cn/posts/fbf7d6843e430133547057254deb2dfb/</link><pubDate>Mon, 07 Jul 2025 18:10:59 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/fbf7d6843e430133547057254deb2dfb/</guid><description>FastAPI 提供了强大的 WebSocket 支持，适用于多种实时通信场景。通过 &lt;code&gt;WebSocket&lt;/code&gt; 类，可以实现文本消息的接收与发送，支持实时聊天、协同编辑等应用。对于二进制数据传输，使用 &lt;code&gt;receive_bytes()&lt;/code&gt; 和 &lt;code&gt;send_bytes()&lt;/code&gt; 方法，适合处理图片、音频等文件。JSON 消息可通过 Pydantic 模型自动解析和验证，确保数据结构正确。此外，通过 &lt;code&gt;asyncio.wait_for&lt;/code&gt; 实现超时控制，定期发送心跳包维持连接。WebSocket 支持多种消息类型，结合异常处理机制，确保通信的稳定性和可靠性。</description></item><item><title>使用Tortoise-ORM和FastAPI构建评论系统</title><link>https://blog.cmdragon.cn/posts/97d9c275881a38c29b26f565d83be9d3/</link><pubDate>Fri, 25 Apr 2025 21:37:36 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/97d9c275881a38c29b26f565d83be9d3/</guid><description>在models.py中定义了Comment模型，包含id、content、created_at、updated_at字段，并与User和Article模型建立外键关系。schemas.py中定义了CommentBase、CommentCreate、CommentUpdate和CommentResponse等Pydantic模型，用于数据验证和响应。路由层实现了创建、获取和删除评论的API，使用get_or_none处理不存在的评论，并捕获异常。测试接口通过requests进行创建和异常测试。常见报错包括外键约束失败、验证错误和事件循环未关闭，需检查外键值、请求体匹配和正确关闭事件循环。</description></item><item><title>FastAPI数据库集成与事务管理</title><link>https://blog.cmdragon.cn/posts/0df867e01706fcb9c2e16ea07671a9e4/</link><pubDate>Fri, 18 Apr 2025 00:15:34 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/0df867e01706fcb9c2e16ea07671a9e4/</guid><description>FastAPI与SQLAlchemy集成指南：首先配置SQLite数据库连接，创建会话工厂和声明性基类。定义用户模型并映射表结构，使用Pydantic进行数据验证。通过依赖项获取数据库会话，实现用户创建和转账功能。事务控制通过显式开始事务和错误处理确保数据一致性。常见问题包括422验证错误、500服务器错误和完整性错误，需检查请求体、数据库连接和约束。课后Quiz解答事务回滚、SQL注入防护和并发写操作处理。</description></item><item><title>FastAPI与SQLAlchemy同步数据库集成</title><link>https://blog.cmdragon.cn/posts/b3bb21bb0bd4c0c405cde6e4f370652c/</link><pubDate>Tue, 15 Apr 2025 01:27:37 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/b3bb21bb0bd4c0c405cde6e4f370652c/</guid><description>FastAPI与SQLAlchemy集成通过ORM框架实现Python类与数据库表的双向转换。SQLAlchemy提供Core层和ORM层，FastAPI选择ORM层以符合Pythonic风格。声明式模型通过&lt;code&gt;declarative_base()&lt;/code&gt;创建基类，定义数据库结构。数据库引擎通过连接字符串配置，会话管理机制确保操作生命周期。完整示例展示了用户管理API的实现，包括创建和查询接口。常见问题涉及会话报错和数据验证错误，解决方案包括检查表结构和验证请求格式。高级配置技巧包括复合索引优化和事务管理。</description></item><item><title>FastAPI中实现动态条件必填字段的实践</title><link>https://blog.cmdragon.cn/posts/93a6982db6ac68a0d9c55169460eda68/</link><pubDate>Thu, 03 Apr 2025 00:06:20 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/93a6982db6ac68a0d9c55169460eda68/</guid><description>在 FastAPI 中，使用 Pydantic 模型实现动态条件必填字段时，需结合 &lt;code&gt;Field&lt;/code&gt; 的 &lt;code&gt;depends&lt;/code&gt; 参数、&lt;code&gt;@model_validator(mode='before')&lt;/code&gt; 装饰器和条件判断逻辑。例如，用户注册接口根据 &lt;code&gt;register_type&lt;/code&gt; 动态决定 &lt;code&gt;email&lt;/code&gt; 或 &lt;code&gt;mobile&lt;/code&gt; 字段是否必填，并在 &lt;code&gt;accept_promotion=True&lt;/code&gt; 时要求至少填写一种联系方式。通过 &lt;code&gt;@model_validator&lt;/code&gt; 在类型转换前验证字段值，确保数据符合条件。测试用例和常见报错解决方案帮助调试和优化验证逻辑。</description></item><item><title>FastAPI中Pydantic异步分布式唯一性校验</title><link>https://blog.cmdragon.cn/posts/e92a3da8b4e4beaf5a14ef4c79489b42/</link><pubDate>Wed, 02 Apr 2025 00:47:55 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/e92a3da8b4e4beaf5a14ef4c79489b42/</guid><description>FastAPI开发中，异步分布式唯一性校验通过异步IO、分布式锁和二级缓存技术解决传统同步校验的并发冲突、性能瓶颈和响应延迟问题。手机和邮箱的唯一性校验通过Pydantic模型定义、异步校验服务层和路由层集成实现。多级缓存策略结合本地缓存、Redis和数据库，确保数据一致性。Redis分布式锁防止并发冲突，速率限制中间件防止恶意请求。常见报错包括锁超时和非法手机号，需调整锁超时时间和净化输入。</description></item><item><title>掌握FastAPI与Pydantic的跨字段验证技巧</title><link>https://blog.cmdragon.cn/posts/2e0c3ce718a08345f384ace84e80e891/</link><pubDate>Tue, 01 Apr 2025 00:32:07 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/2e0c3ce718a08345f384ace84e80e891/</guid><description>FastAPI中的Pydantic跨字段一致性验证用于处理用户注册、表单提交等场景中多个字段的联合验证需求。Pydantic通过验证器装饰器和根验证器实现字段间的联合判断，如密码确认、邮箱匹配等。文章详细介绍了验证器的基础用法、最佳实践示例以及如何在FastAPI中集成验证逻辑。进阶技巧包括自定义验证方法和组合验证规则。常见报错解决方案和最佳实践总结帮助开发者构建健壮的API系统。</description></item><item><title>FastAPI中的Pydantic密码验证机制与实现</title><link>https://blog.cmdragon.cn/posts/a72a86da313f399c29b36ec08f75361d/</link><pubDate>Mon, 31 Mar 2025 00:04:51 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/a72a86da313f399c29b36ec08f75361d/</guid><description>FastAPI 中通过 Pydantic 模型实现密码验证，采用分层机制确保高效与灵活扩展。验证流程包括基础类型检查、长度验证、复杂度验证和泄露检测，任一阶段失败即终止后续验证。通过 &lt;code&gt;SecretStr&lt;/code&gt; 安全获取密码明文，结合正则表达式验证密码复杂度，并利用哈希函数检测密码是否泄露。模块化设计便于后续添加更多安全规则，如密码过期策略和历史密码比对。</description></item></channel></rss>