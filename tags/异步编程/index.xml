<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>异步编程 on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link><description>Recent content in 异步编程 on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 24 Aug 2025 23:35:36 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>冷热任务分离：是提升Web性能的终极秘籍还是技术噱头？</title><link>https://blog.cmdragon.cn/posts/9c3dc7767a9282f7ef02daad42539f2c/</link><pubDate>Sun, 24 Aug 2025 23:35:36 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/9c3dc7767a9282f7ef02daad42539f2c/</guid><description>冷热任务分离是提升Web应用性能的关键策略，热任务要求毫秒级响应，直接影响用户体验，如API主逻辑和数据库查询；冷任务可延后处理，如发送邮件和日志写入。通过任务解耦，热任务即时响应，冷任务进入队列异步执行，提升吞吐量、增强稳定性并优化资源。FastAPI支持原生后台任务和Celery分布式队列两种实现方案，适用于不同场景。最佳实践包括任务切分、监控指标和资源分配比例，确保系统高效运行。</description></item><item><title>如何在 FastAPI 中优雅处理后台任务异常并实现智能重试？</title><link>https://blog.cmdragon.cn/posts/d5c1d2efbaf6fe4c9e13acc6be6d929a/</link><pubDate>Tue, 05 Aug 2025 03:53:28 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/d5c1d2efbaf6fe4c9e13acc6be6d929a/</guid><description>FastAPI 的 BackgroundTasks 是一种轻量级异步任务处理方案，基于 Starlette 的异步执行机制，适用于短期任务。文章深入探讨了其核心原理、异常处理和任务重试机制。通过自定义异常处理器和任务级错误捕获，可以有效处理后台任务中的异常。结合装饰器和 tenacity 库，实现了指数退避重试和异步重试策略。最后，文章通过一个支付回调通知系统的案例，展示了如何综合应用这些技术，确保任务的可靠执行。</description></item><item><title>FastAPI后台任务：是时候让你的代码飞起来了吗？</title><link>https://blog.cmdragon.cn/posts/6145d88d5154d5cd38cee7ddc2d46e1d/</link><pubDate>Sat, 02 Aug 2025 06:59:15 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6145d88d5154d5cd38cee7ddc2d46e1d/</guid><description>FastAPI的BackgroundTasks机制允许在请求响应后执行后台任务，适用于邮件发送、数据清理等场景。其核心特点包括任务队列、自动依赖注入和异常隔离。生产级代码示例展示了用户注册时发送欢迎邮件的实现。高级应用场景包括数据库事务补偿和任务编排模式。性能优化策略涉及任务分片、资源限制和超时设置。典型报错处理强调了后台任务不应返回响应对象，而应独立处理。</description></item><item><title>FastAPI后台任务为何能让邮件发送如此丝滑？</title><link>https://blog.cmdragon.cn/posts/19241679a1852122f740391cbdc21bae/</link><pubDate>Fri, 01 Aug 2025 08:22:50 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/19241679a1852122f740391cbdc21bae/</guid><description>FastAPI通过BackgroundTasks模块实现异步后台任务处理，具有任务执行与请求处理解耦、支持依赖注入、自动处理异常等特点。实战中，通过aiosmtplib集成SMTP协议实现邮件通知功能，支持SSL加密连接和Jinja2模板引擎。日志系统采用结构化日志配置和请求日志中间件，优化建议包括使用RotatingFileHandler、接入ELK或Sentry日志系统及敏感信息过滤。常见问题涉及后台任务未执行和SMTP认证错误，解决方案包括检查路由、验证异步执行和SMTP配置。</description></item><item><title>FastAPI遇上GraphQL：异步解析器如何让API性能飙升？</title><link>https://blog.cmdragon.cn/posts/35fced261e8ff834e68e07c93902cc13/</link><pubDate>Sat, 19 Jul 2025 05:41:41 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/35fced261e8ff834e68e07c93902cc13/</guid><description>GraphQL相比RESTful API通过单一智能端点减少网络开销，避免数据冗余。FastAPI通过Starlette中间件实现GraphQL路由挂载，处理流程包括解析查询、批量数据请求和异步查询。异步解析器使用Python 3.11的async/await语法提升IO效率。DataLoader优化N+1查询，通过缓存和请求合并技术避免数据库查询风暴。常见报错如字段缺失或权限问题，可通过检查schema定义、验证数据源和添加权限校验解决。</description></item><item><title>GraphQL的N+1问题如何被DataLoader巧妙化解？</title><link>https://blog.cmdragon.cn/posts/72629304782a121fbf89b151c436f9aa/</link><pubDate>Thu, 17 Jul 2025 07:50:56 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/72629304782a121fbf89b151c436f9aa/</guid><description>N+1问题在GraphQL嵌套查询中表现为查询次数与结果集大小成正比，导致效率低下。DataLoader通过批处理机制、请求缓存和异步支持解决这一问题，将多个关联查询请求合并为批量操作，提升性能。FastAPI集成DataLoader时，需配置环境、定义数据模型并实现批量查询函数。性能测试显示，使用DataLoader后，平均响应时间从850ms降至120ms，TPS从117提升到833。典型报错如缺少子字段选择，需明确指定返回字段。</description></item><item><title>异步日志监控：FastAPI与MongoDB的高效整合之道</title><link>https://blog.cmdragon.cn/posts/0f2382680f9cbcb6976ec2baa5cf2fa2/</link><pubDate>Tue, 27 May 2025 17:49:39 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/0f2382680f9cbcb6976ec2baa5cf2fa2/</guid><description>FastAPI与MongoDB整合实现日志监控系统的实战指南。首先配置MongoDB异步连接，定义日志数据模型。核心功能包括日志写入接口、聚合管道查询和索引优化。性能优化技巧涵盖批量写入和查询分页。常见报错解决方案涉及422 Validation Error和MongoClient连接超时。生产环境建议包括连接池配置、读写分离、慢查询监控和TTL索引。通过该方案，可构建日均千万级日志处理系统，建议配合Prometheus和Grafana进行监控和可视化。</description></item><item><title>FastAPI与MongoDB Change Stream的实时数据交响曲</title><link>https://blog.cmdragon.cn/posts/c61df2f044f3ffda6fd2eb4c5dd72620/</link><pubDate>Sun, 25 May 2025 13:04:40 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c61df2f044f3ffda6fd2eb4c5dd72620/</guid><description>MongoDB Change Stream与FastAPI集成可实现毫秒级实时数据处理。Change Stream通过oplog机制捕获数据变更事件，支持insert、update、replace、delete操作监听，具备断点续传和事件过滤能力。集成步骤包括环境准备、基础监听实现、WebSocket实时推送，以及性能优化策略如索引优化、批处理配置和资源控制。生产环境建议使用独立物理节点部署oplog，配置心跳检测，并监控事件处理延迟、内存使用和网络带宽消耗。该方案适用于实时数据分析、即时通讯和物联网等场景。</description></item><item><title>异步日志分析：MongoDB与FastAPI的高效存储揭秘</title><link>https://blog.cmdragon.cn/posts/1963035336232d8e37bad41071f21fba/</link><pubDate>Thu, 22 May 2025 17:04:56 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/1963035336232d8e37bad41071f21fba/</guid><description>MongoDB与FastAPI集成构建日志分析系统，通过Motor驱动实现异步操作，提升数据处理效率。使用Pydantic进行数据验证，配置环境变量，创建REST API端点。聚合管道用于日志统计，如按级别分组计数。索引优化策略通过创建复合索引和文本索引，显著提升查询性能。完整案例实现错误追踪和日志搜索功能。常见报错包括422验证错误和连接超时，提供具体解决方案。课后Quiz强调索引优化、高效分页和写入可靠性。</description></item><item><title>异步之舞：FastAPI与MongoDB的深度协奏</title><link>https://blog.cmdragon.cn/posts/b448df6a7d6354d67c30d7a4a46d0c0c/</link><pubDate>Sun, 18 May 2025 19:09:08 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/b448df6a7d6354d67c30d7a4a46d0c0c/</guid><description>MongoDB与FastAPI的基础集成方法。首先，环境要求包括Python 3.8+、MongoDB 4.4+、FastAPI 0.95+和Motor 3.1+，并提供了依赖安装命令。其次，通过Motor驱动配置异步数据库连接，使用Pydantic进行数据验证，并实现异步CRUD操作。此外，还展示了聚合管道实践和索引优化策略，如创建单字段索引、复合索引和文本索引。最后，提供了常见报错的解决方案，如ServerSelectionTimeoutError、ValidationError和查询性能低下的处理方法。</description></item><item><title>数据库连接池：从银行柜台到代码世界的奇妙旅程</title><link>https://blog.cmdragon.cn/posts/1d808e4e97f59c12d2e5cf3302f3e1a7/</link><pubDate>Wed, 07 May 2025 23:52:52 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/1d808e4e97f59c12d2e5cf3302f3e1a7/</guid><description>FastAPI开发中，Tortoise-ORM的数据库连接池配置对系统性能至关重要。连接池参数如maxsize、timeout和pool_recycle直接影响并发处理能力。通过动态调整连接池大小、集成Prometheus监控和设置告警规则，可以有效优化性能。常见错误如连接池耗尽可通过逐步增加maxsize和优化慢查询解决。综合监控指标和压力测试工具，可以全面评估连接池状态，确保系统稳定性。</description></item><item><title>DDD分层设计与异步职责划分：让你的代码不再“异步”混乱</title><link>https://blog.cmdragon.cn/posts/56102650d57c260e04435fe72e541ee3/</link><pubDate>Sun, 04 May 2025 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/56102650d57c260e04435fe72e541ee3/</guid><description>DDD分层架构将系统分为用户接口层、应用层、领域层和基础设施层，各层职责明确。领域层处理同步业务逻辑，基础设施层负责异步数据库操作，应用层协调两者。评论模块使用pydantic定义领域模型，保持业务逻辑完整性。Tortoise-ORM实现基础设施层的异步仓储操作。应用层整合领域逻辑与基础设施的异步调用，确保事务管理策略通过原子操作实现。分层调用规则强调领域对象不包含await调用，仓储接口定义在领域层，实现在基础设施层。</description></item><item><title>异步IO与Tortoise-ORM的数据库</title><link>https://blog.cmdragon.cn/posts/618edd124a0fe8340f766e276faa89fb/</link><pubDate>Tue, 29 Apr 2025 13:21:47 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/618edd124a0fe8340f766e276faa89fb/</guid><description>异步IO与同步IO的核心区别在于阻塞与非阻塞模式。Tortoise-ORM通过协议层、连接池层和ORM层实现异步数据库操作，支持高效的并发处理。用户管理系统搭建中，Tortoise-ORM与FastAPI结合，实现了用户创建和查询功能，并通过Pydantic进行数据校验。异步ORM适用于高并发场景，参数化查询可防止SQL注入。最佳实践包括连接池配置、查询优化和事务管理，确保系统性能和数据一致性。</description></item><item><title>异步编程与Tortoise-ORM框架</title><link>https://blog.cmdragon.cn/posts/5265d648f0fd4ea5e11af203bc59301d/</link><pubDate>Sat, 19 Apr 2025 00:13:05 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/5265d648f0fd4ea5e11af203bc59301d/</guid><description>异步编程通过async/await语法实现协程，单线程可处理多个并发请求，适合IO密集型场景。Tortoise-ORM专为异步设计，支持完整ORM功能和多种数据库，与Pydantic深度集成。整合FastAPI时，通过&lt;code>register_tortoise&lt;/code>初始化ORM，使用&lt;code>in_transaction&lt;/code>管理事务，确保操作原子性。常见问题包括未使用await返回协程对象和事件循环关闭错误，需通过正确的事件循环启动和事务管理解决。</description></item><item><title>FastAPI依赖注入性能优化策略</title><link>https://blog.cmdragon.cn/posts/80f30f46ece634f36b143b3a1fe6e82a/</link><pubDate>Sat, 12 Apr 2025 00:53:48 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/80f30f46ece634f36b143b3a1fe6e82a/</guid><description>FastAPI依赖注入机制通过将对象创建与使用分离，提升了代码的可测试性和可维护性。优化策略包括区分同步与异步依赖，异步依赖适用于I/O密集型操作；使用&lt;code>lru_cache&lt;/code>缓存依赖计算结果，减少重复计算；对数据库连接等重量级资源采用单例模式。实战案例展示了用户认证系统的优化方案，通过缓存JWT解码结果提高性能。开发环境配置和常见报错处理也提供了具体指导。</description></item><item><title>FastAPI中的依赖注入与数据库事务管理</title><link>https://blog.cmdragon.cn/posts/edd7eaa71626c5d5d95f7a07c538cfe1/</link><pubDate>Wed, 09 Apr 2025 00:10:29 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/edd7eaa71626c5d5d95f7a07c538cfe1/</guid><description>文章介绍了在FastAPI中使用依赖注入和SQLAlchemy进行数据库会话封装的方法，提供了三种事务管理模式的实现：自动事务模式、手动控制模式和装饰器模式。通过代码示例展示了如何创建用户注册功能，并处理事务和错误。强调了使用参数化查询防止SQL注入攻击的重要性，并提供了常见报错的解决方案，包括检查数据库连接参数、管理会话生命周期和调整连接池设置。</description></item><item><title>深入理解Python多进程：从基础到实战</title><link>https://blog.cmdragon.cn/posts/e812fcfaa2f6e1e4e25715242373b47b/</link><pubDate>Mon, 29 Apr 2024 20:49:41 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/e812fcfaa2f6e1e4e25715242373b47b/</guid><description>&lt;img src="https://blog.cmdragon.cn/images/2024_04_29 20_53_37.png" title="2024_04_29 20_53_37.png" alt="2024_04_29 20_53_37.png"/>
&lt;h2 id="引言">&lt;strong>引言&lt;/strong>&lt;/h2>
&lt;p>在Python编程中，多进程是一种重要的并发编程方式，可以让我们充分利用多核处理器的计算能力，实现并行处理任务，提高程序的运行效率。与多线程相比，多进程具有独立的内存空间，避免了全局解释器锁（GIL）的影响，因此更适合于CPU密集型的任务。&lt;/p></description></item><item><title>深入理解多线程编程</title><link>https://blog.cmdragon.cn/posts/adaeacb52ca7729c73c2d63d95a0ffe2/</link><pubDate>Thu, 25 Apr 2024 17:32:02 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/adaeacb52ca7729c73c2d63d95a0ffe2/</guid><description>&lt;img src="https://blog.cmdragon.cn/images/2024_04_25 17_38_00.png" title="2024_04_25 17_38_00.png" alt="2024_04_25 17_38_00.png"/>
&lt;h2 id="第一章多线程基础">&lt;strong>第一章：多线程基础&lt;/strong>&lt;/h2>
&lt;h3 id="11-线程概念与原理">&lt;strong>1.1 线程概念与原理&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>线程&lt;/strong>：在操作系统中，一个程序可以被划分为多个执行流，每个执行流就是一个独立的线程。线程是进程中的一个执行实体，它可以拥有自己的局部变量、栈和程序计数器。&lt;/li>
&lt;li>&lt;strong>并发执行&lt;/strong>：线程允许程序同时执行多个任务，每个任务在单个处理器核心上交替执行，看起来像是同时进行的。&lt;/li>
&lt;li>&lt;strong>线程与进程的区别&lt;/strong>：线程是进程内的一个执行单元，进程是资源分配和独立执行的基本单位。一个进程可以包含多个线程，但一个线程只能属于一个进程。&lt;/li>
&lt;/ul>
&lt;h3 id="12-多线程编程的优势">&lt;strong>1.2 多线程编程的优势&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>提高响应性&lt;/strong>：多线程允许程序在等待I/O操作时继续执行其他任务，提高用户体验。&lt;/li>
&lt;li>&lt;strong>资源利用&lt;/strong>：通过并发，可以更有效地利用处理器的多核心优势，提高系统性能。&lt;/li>
&lt;li>&lt;strong>任务并行&lt;/strong>：适合处理大量独立或部分独立的计算任务，如网络请求、文件处理等。&lt;/li>
&lt;/ul>
&lt;h3 id="13-多线程编程的应用场景">&lt;strong>1.3 多线程编程的应用场景&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Web服务器&lt;/strong>：处理并发请求，每个请求作为独立的线程处理。&lt;/li>
&lt;li>&lt;strong>游戏开发&lt;/strong>：游戏中的多线程用于音频、图形渲染和逻辑处理的分离。&lt;/li>
&lt;li>&lt;strong>数据分析&lt;/strong>：大数据处理、机器学习中的并行计算。&lt;/li>
&lt;li>&lt;strong>用户界面&lt;/strong>：线程可以用于实现后台任务的异步执行，避免阻塞UI线程。&lt;/li>
&lt;/ul>
&lt;h3 id="14-线程的创建与销毁">&lt;strong>1.4 线程的创建与销毁&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>创建线程&lt;/strong>：&lt;/p></description></item></channel></rss>