<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/RabbitMQ/</link><description>Recent content in RabbitMQ on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 23 Aug 2025 05:07:15 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/RabbitMQ/index.xml" rel="self" type="application/rss+xml"/><item><title>如何让FastAPI与消息队列的联姻既甜蜜又可靠？</title><link>https://blog.cmdragon.cn/posts/1bebb53f4d9d6fbd0ecbba97562c07b0/</link><pubDate>Sat, 23 Aug 2025 05:07:15 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/1bebb53f4d9d6fbd0ecbba97562c07b0/</guid><description>消息队列与FastAPI集成在分布式系统中用于解耦服务，通过异步特性支持消息事务和幂等性保障。消息事务确保数据库操作与消息发送的原子性，避免数据不一致。幂等性设计通过唯一ID和Redis校验防止消息重复处理。关键解决方案包括事务型消息、幂等令牌和全局唯一ID。常见报错如422和503，可通过校验模型、重试机制和连接池解决。依赖库包括FastAPI、SQLAlchemy、Redis和Pika。</description></item><item><title>如何在FastAPI中巧妙实现延迟队列，让任务乖乖等待？</title><link>https://blog.cmdragon.cn/posts/174450702d9e609a072a7d1aaa84750b/</link><pubDate>Fri, 22 Aug 2025 14:32:13 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/174450702d9e609a072a7d1aaa84750b/</guid><description>消息队列是分布式系统中实现异步通信的核心组件，延迟队列则允许在指定时间后投递消息，适用于定时任务和失败重试等场景。FastAPI中推荐使用Redis或RabbitMQ作为消息中间件，结合Celery或arq实现延迟队列。Redis通过Sorted Set和arq实现全异步延迟队列，RabbitMQ则利用死信队列实现延迟投递。实际应用包括电商订单超时、会议提醒、重试机制和定时报告等。常见问题如422验证错误和连接拒绝错误，需检查数据格式和连接参数。</description></item><item><title>FastAPI的死信队列处理机制：为何你的消息系统需要它？</title><link>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</link><pubDate>Thu, 21 Aug 2025 04:33:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</guid><description>死信队列（DLQ）用于处理消息系统中的失败消息，确保主业务流程不被阻塞。FastAPI结合RabbitMQ实现死信队列，通过配置死信交换机和队列，处理消息拒收、TTL过期、队列满和重试耗尽等场景。使用Pydantic验证消息格式，确保数据有效性。FastAPI消费者服务处理消息时，若失败则触发死信路由，消息最终进入死信队列。实现包括队列初始化、消息验证、异常处理和死信路由，确保系统健壮性。</description></item><item><title>如何让Celery任务像VIP客户一样享受优先待遇？</title><link>https://blog.cmdragon.cn/posts/c24491a7ac7f7c5e9cf77596ebb27c51/</link><pubDate>Tue, 12 Aug 2025 06:27:36 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c24491a7ac7f7c5e9cf77596ebb27c51/</guid><description>在 FastAPI 中集成 Celery 实现任务优先级队列，需配置 Redis 或 RabbitMQ 作为 Broker。通过定义不同优先级的队列（如 high_priority 和 low_priority），结合 Pydantic 模型验证任务数据，动态分配任务到相应队列。RabbitMQ 支持设置任务优先级范围，确保高优先级任务优先处理。实践案例中，订单处理系统根据用户类型和优先级动态调整任务执行顺序。启动 worker 时需指定队列，并监控队列积压情况，确保任务按预期优先级执行。</description></item><item><title>FastAPI消息持久化与ACK机制：如何确保你的任务永不迷路？</title><link>https://blog.cmdragon.cn/posts/13a59846aaab71b44ab6f3dadc5b5ec7/</link><pubDate>Sat, 09 Aug 2025 04:51:03 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/13a59846aaab71b44ab6f3dadc5b5ec7/</guid><description>FastAPI框架中，消息持久化和ACK确认机制是确保任务可靠执行的关键。默认的内存任务存储存在服务器重启丢失和高并发内存压力问题。通过消息队列和持久化数据库备份实现任务持久化，结合ACK确认机制确保消息被正确处理后才移除。Celery+RabbitMQ集成方案提供高效的任务调度和队列管理。增强型任务模型支持优先级和过期时间设置。常见报错如502 Bad Gateway和422 Validation Error需检查消息队列连接和任务模型字段验证。</description></item><item><title>BackgroundTasks 还是 RabbitMQ？你的异步任务到底该选谁？</title><link>https://blog.cmdragon.cn/posts/d26fdc150ff9dd70c7482381ff4c77c4/</link><pubDate>Thu, 07 Aug 2025 07:20:32 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/d26fdc150ff9dd70c7482381ff4c77c4/</guid><description>FastAPI 的 BackgroundTasks 适用于轻量级任务，如日志记录和邮件发送，执行时间通常小于 3 秒。对于耗时任务，如图片处理和数据分析，推荐使用 RabbitMQ 结合 Celery。RabbitMQ 提供了消息持久化、任务重试和高并发处理能力，确保任务不丢失。通过 Pydantic 模型设计任务负载，生产者将任务提交到队列，消费者异步处理任务。综合案例展示了图片水印处理系统的实现，结合 BackgroundTasks 和 RabbitMQ 的优势，提升系统性能和可靠性。</description></item></channel></rss>