<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>错误处理 on cmdragon's Blog</title><link>https://blog.cmdragon.cn/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><description>Recent content in 错误处理 on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 21 Aug 2025 04:33:54 +0800</lastBuildDate><atom:link href="https://blog.cmdragon.cn/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>FastAPI的死信队列处理机制：为何你的消息系统需要它？</title><link>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</link><pubDate>Thu, 21 Aug 2025 04:33:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/047b08957a0d617a87b72da6c3131e5d/</guid><description>死信队列（DLQ）用于处理消息系统中的失败消息，确保主业务流程不被阻塞。FastAPI结合RabbitMQ实现死信队列，通过配置死信交换机和队列，处理消息拒收、TTL过期、队列满和重试耗尽等场景。使用Pydantic验证消息格式，确保数据有效性。FastAPI消费者服务处理消息时，若失败则触发死信路由，消息最终进入死信队列。实现包括队列初始化、消息验证、异常处理和死信路由，确保系统健壮性。</description></item><item><title>定时任务系统如何让你的Web应用自动完成那些烦人的重复工作？</title><link>https://blog.cmdragon.cn/posts/2b27950aab76203a1af4e9e3deda8699/</link><pubDate>Thu, 14 Aug 2025 05:55:20 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/2b27950aab76203a1af4e9e3deda8699/</guid><description>定时任务系统是Web应用中自动执行任务的重要机制，广泛应用于数据清理、报表生成、状态刷新和批量处理等场景。FastAPI中主要通过后台任务队列和定时调度系统实现，其中APScheduler是最成熟的Python调度库，支持多种调度器和存储方案。APScheduler的集成示例展示了如何在FastAPI中初始化调度器、添加任务以及安全终止调度器。实战案例以电商订单超时处理为例，演示了如何通过定时任务自动取消未支付订单。常见错误包括任务未按预期执行、调度器未启动等，可通过检查任务状态、设置时区等方法解决。</description></item><item><title>如何让你的FastAPI Celery Worker在压力下优雅起舞？</title><link>https://blog.cmdragon.cn/posts/c3129f4b424d2ed2330484b82ec31875/</link><pubDate>Mon, 11 Aug 2025 08:31:32 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c3129f4b424d2ed2330484b82ec31875/</guid><description>FastAPI 项目中配置 Celery Worker 涉及基础设置、自动扩展和容器化部署。首先，在 celery_app.py 中定义 Celery 应用，配置任务路由和 Redis 作为消息代理。通过命令行参数控制 Worker 的并发数、日志级别和队列监听。自动扩展功能通过 SmartAutoscaler 类实现，根据 CPU 使用率动态调整 Worker 数量。Docker Compose 部署方案包括 Redis 和 Worker 服务，支持多副本和资源限制。监控与日志配置使用结构化日志记录，便于任务追踪。常见错误如 WorkerLostError 和协议不匹配，可通过调整系统设置和协议版本解决。</description></item><item><title>FastAPI与Celery的完美邂逅，如何让异步任务飞起来？</title><link>https://blog.cmdragon.cn/posts/b79c2c1805fe9b1ea28326b5b8f3b709/</link><pubDate>Sun, 10 Aug 2025 07:43:41 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/b79c2c1805fe9b1ea28326b5b8f3b709/</guid><description>FastAPI框架集成Celery的实战指南，首先需要Python 3.8+环境，并安装FastAPI、Celery、Redis等核心依赖包。配置Celery实例时，需设置Redis作为Broker和Backend。异步任务处理流程包括用户请求通过FastAPI路由进入，Celery任务派发，Worker执行任务并存储结果。接口层实现中，通过FastAPI创建任务和查询任务状态的API。任务处理器使用Celery的&lt;code>@shared_task&lt;/code>装饰器定义异步任务。任务监控通过Flower平台进行，配置Celery以发送任务事件。常见报错包括Worker启动失败、任务执行超时和结果反序列化失败，需检查Redis服务、调整任务超时设置和确保任务返回可序列化对象。</description></item><item><title>BackgroundTasks与Celery：谁才是异步任务的终极赢家？</title><link>https://blog.cmdragon.cn/posts/792cac4ce6eb96b5001da15b0d52ef83/</link><pubDate>Wed, 06 Aug 2025 00:27:54 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/792cac4ce6eb96b5001da15b0d52ef83/</guid><description>FastAPI的BackgroundTasks模块适用于短时任务（如邮件发送、日志写入），基于请求-响应后的异步执行机制，但不支持任务持久化和分布式处理。与Celery相比，BackgroundTasks适合处理5秒内的任务，而Celery适合长时间任务和分布式场景。消息队列的核心组件包括Broker、生产者-消费者模式和消息确认机制。混合架构可结合BackgroundTasks和Celery，分别处理快速和慢速任务。长时间任务应使用Celery，避免阻塞FastAPI事件循环。</description></item><item><title>BackgroundTasks 如何巧妙驾驭多任务并发？</title><link>https://blog.cmdragon.cn/posts/8661dc74944bd6fb28092e90d4060161/</link><pubDate>Mon, 04 Aug 2025 11:13:25 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/8661dc74944bd6fb28092e90d4060161/</guid><description>BackgroundTasks 适用于处理短时任务，通过将任务加入队列并在后台执行，实现异步处理。多任务并发控制可通过 Semaphore 限制最大并发数，优先级任务调度则通过装饰器实现优先级队列。长时间任务建议使用 Celery，以避免任务丢失和缺乏分布式追踪能力。常见报错包括 422 验证错误、后台任务未执行和并发超限错误，可通过检查模型定义、正确传递参数和初始化全局信号量等方式解决。</description></item><item><title>FastAPI后台任务：是时候让你的代码飞起来了吗？</title><link>https://blog.cmdragon.cn/posts/6145d88d5154d5cd38cee7ddc2d46e1d/</link><pubDate>Sat, 02 Aug 2025 06:59:15 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6145d88d5154d5cd38cee7ddc2d46e1d/</guid><description>FastAPI的BackgroundTasks机制允许在请求响应后执行后台任务，适用于邮件发送、数据清理等场景。其核心特点包括任务队列、自动依赖注入和异常隔离。生产级代码示例展示了用户注册时发送欢迎邮件的实现。高级应用场景包括数据库事务补偿和任务编排模式。性能优化策略涉及任务分片、资源限制和超时设置。典型报错处理强调了后台任务不应返回响应对象，而应独立处理。</description></item><item><title>FastAPI的请求-响应周期为何需要后台任务分离？</title><link>https://blog.cmdragon.cn/posts/c7b54d6b3b6b5041654e69e5610bf3b9/</link><pubDate>Thu, 31 Jul 2025 06:11:25 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c7b54d6b3b6b5041654e69e5610bf3b9/</guid><description>FastAPI 的请求-响应周期遵循 ASGI 协议，类似于餐厅点餐流程。同步处理耗时操作会导致服务阻塞，影响性能。通过 &lt;code>BackgroundTasks&lt;/code> 实现后台任务分离，任务分发器创建独立任务单元，工作线程池异步执行。&lt;code>BackgroundTasks&lt;/code> 适用于短时任务，而 Celery 更适合长时间任务和跨进程执行。任务中访问数据库时应重新建立连接，避免依赖生命周期问题。错误处理可通过即时捕获或延迟记录模式实现，推荐使用装饰器封装任务函数。</description></item><item><title>如何在FastAPI中让后台任务既高效又不会让你的应用崩溃？</title><link>https://blog.cmdragon.cn/posts/5ad8d0a4c8f2d05e9c1a42d828aad7b3/</link><pubDate>Wed, 30 Jul 2025 12:01:00 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/5ad8d0a4c8f2d05e9c1a42d828aad7b3/</guid><description>FastAPI 的 BackgroundTasks 允许将非即时性操作（如发送邮件、日志记录）从主请求流程中分离，提升响应速度并支持同步/异步混合任务处理。通过注入 BackgroundTasks 参数并使用 add_task 方法添加任务，开发者可以轻松实现后台任务。高级功能包括依赖注入增强和混合任务处理，测试时可通过 pytest 进行单元测试和集成测试。后台任务异常不会影响主请求响应，需通过自定义错误处理中间件捕获。</description></item><item><title>FastAPI后台任务：异步魔法还是同步噩梦？</title><link>https://blog.cmdragon.cn/posts/6a69eca9fd14ba8f6fa41502c5014edd/</link><pubDate>Tue, 29 Jul 2025 10:00:09 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6a69eca9fd14ba8f6fa41502c5014edd/</guid><description>FastAPI中的后台任务用于处理不需要立即返回给客户端的耗时操作，如发送邮件或处理文件。通过&lt;code>BackgroundTasks&lt;/code>将任务加入队列，系统在响应返回后异步执行任务。核心原理包括任务注册机制和FIFO执行时序控制，默认使用线程池执行任务。典型应用场景包括邮件通知、文件批处理和数据清洗。常见报错如422 Validation Error和500 Internal Server Error，可通过检查请求体、添加默认值和使用错误重试机制解决。</description></item><item><title>如何在FastAPI中玩转Schema版本管理和灰度发布？</title><link>https://blog.cmdragon.cn/posts/6d9d20cd8d8528da4193f13aaf98575c/</link><pubDate>Mon, 28 Jul 2025 07:28:31 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6d9d20cd8d8528da4193f13aaf98575c/</guid><description>Schema版本管理通过Pydantic的模型继承机制实现接口兼容性，采用语义化版本控制确保v1.1.0向下兼容v1.0.0。多版本共存通过基础模型和版本路由实现，使用Union类型处理不同版本的返回数据。灰度发布通过请求头实现路由，采用金丝雀发布策略逐步扩大新版本使用范围，监控指标异常时自动回滚。典型报错如422、503和版本冲突，通过检查请求头、健康检查端点和异常处理流程解决。</description></item><item><title>如何在FastAPI中玩转GraphQL联邦架构，让数据源手拉手跳探戈？</title><link>https://blog.cmdragon.cn/posts/9b9086ff5d8464b0810cfb55f7768513/</link><pubDate>Thu, 24 Jul 2025 05:59:03 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/9b9086ff5d8464b0810cfb55f7768513/</guid><description>GraphQL联邦架构通过服务注册机制整合多源数据，核心组件包括网关服务和多个子服务。各子服务维护独立Schema，通过@key指令实现跨服务实体关联，网关自动处理跨服务查询。FastAPI集成联邦架构时，需分别实现用户服务和商品服务，并在网关服务中配置服务列表。性能优化策略包括查询缓存、批量加载和复杂度限制。常见报错如Schema合并冲突、查询超时和类型验证失败，可通过检查@key指令、分析查询复杂度和验证Schema类型定义解决。</description></item><item><title>如何在FastAPI中整合GraphQL的复杂度与限流？</title><link>https://blog.cmdragon.cn/posts/ace8bb3f01589994f51d748ab5c73652/</link><pubDate>Mon, 21 Jul 2025 08:30:34 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/ace8bb3f01589994f51d748ab5c73652/</guid><description>GraphQL 在 FastAPI 中的集成提升了数据获取效率，但复杂查询可能引发性能问题。通过复杂度分析机制，如计算查询深度和字段数量，可有效控制查询复杂度。限流策略基于令牌桶算法，结合中间件实现，防止系统过载。整合复杂度与限流系统，在路由级别实现双重防护，确保 API 稳定性。常见报错如 HTTP 422 可通过检查请求体规范和使用调试模式解决。依赖库包括 FastAPI、Pydantic、Graphene 和 Slowapi。</description></item><item><title>GraphQL错误处理为何让你又爱又恨？FastAPI中间件能否成为你的救星？</title><link>https://blog.cmdragon.cn/posts/a28d5c1b32feadb18b406a849455dfe5/</link><pubDate>Sun, 20 Jul 2025 04:36:48 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/a28d5c1b32feadb18b406a849455dfe5/</guid><description>GraphQL的错误处理机制在API开发中至关重要，其结构化错误信息和细粒度控制优于传统REST API。FastAPI中间件通过管道式处理架构捕获请求全生命周期的异常，实现统一错误处理。中间件实现包括错误模型定义、异常捕获和格式化错误响应，支持验证错误和业务异常的场景化处理。常见报错如422验证错误可通过自定义标量类型和中间件统一转换解决。课后Quiz探讨了多字段错误路径准确性和第三方服务异常处理方案。</description></item><item><title>FastAPI遇上GraphQL：异步解析器如何让API性能飙升？</title><link>https://blog.cmdragon.cn/posts/35fced261e8ff834e68e07c93902cc13/</link><pubDate>Sat, 19 Jul 2025 05:41:41 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/35fced261e8ff834e68e07c93902cc13/</guid><description>GraphQL相比RESTful API通过单一智能端点减少网络开销，避免数据冗余。FastAPI通过Starlette中间件实现GraphQL路由挂载，处理流程包括解析查询、批量数据请求和异步查询。异步解析器使用Python 3.11的async/await语法提升IO效率。DataLoader优化N+1查询，通过缓存和请求合并技术避免数据库查询风暴。常见报错如字段缺失或权限问题，可通过检查schema定义、验证数据源和添加权限校验解决。</description></item><item><title>FastAPI与GraphQL的完美邂逅：如何打造高效API？</title><link>https://blog.cmdragon.cn/posts/fb5c5c7b00bbe57b3a5346b8ee5bc289/</link><pubDate>Wed, 16 Jul 2025 10:47:21 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/fb5c5c7b00bbe57b3a5346b8ee5bc289/</guid><description>FastAPI与GraphQL集成通过Ariadne库实现，支持查询、变更和订阅操作。查询操作通过GraphQL解析器获取数据并验证格式，变更操作使用Pydantic进行数据验证和持久化存储，订阅操作通过WebSocket实现实时消息推送。项目采用分层架构，核心操作包括用户查询、创建和消息订阅。常见错误如422验证错误和类型解析错误，可通过检查请求参数、使用Pydantic模型和自定义标量解析器解决。</description></item><item><title>如何在FastAPI中玩转STOMP协议升级，让你的消息传递更高效？</title><link>https://blog.cmdragon.cn/posts/16744b2f460346805c45314bc0c6f751/</link><pubDate>Sat, 12 Jul 2025 17:54:29 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/16744b2f460346805c45314bc0c6f751/</guid><description>STOMP协议是一种基于文本的轻量级消息协议，常用于发布/订阅模式。在FastAPI中实现STOMP协议的核心是通过WebSocket建立连接后，添加STOMP协议解析器。实现过程包括三个阶段：客户端发送&lt;code>CONNECT&lt;/code>帧建立会话，使用&lt;code>SUBSCRIBE&lt;/code>命令订阅消息通道，通过&lt;code>SEND&lt;/code>命令发送消息。示例代码展示了如何在FastAPI中解析STOMP帧、管理会话和订阅关系。最佳实践包括消息广播功能的实现，以及处理常见报错如协议版本不匹配和连接关闭问题。</description></item><item><title>如何让多客户端会话管理不再成为你的技术噩梦？</title><link>https://blog.cmdragon.cn/posts/08ba771dbb2eec087c4bc6dc584113c5/</link><pubDate>Tue, 08 Jul 2025 16:59:02 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/08ba771dbb2eec087c4bc6dc584113c5/</guid><description>会话标识采用UUID4算法生成128位全局唯一标识，结合HMAC-SHA256签名确保防篡改。Redis会话存储方案使用连接池管理Redis连接，配置参数包括最大连接数和超时重试。数据库连接池配置使用asyncpg实现PostgreSQL连接池，设置连接池大小和溢出限制。负载均衡健康检查接口通过Kubernetes就绪检查确保服务可用性。WebSocket群组管理采用发布-订阅模式实现消息广播，管理活跃连接。断线重连机制通过客户端心跳包和服务端连接监测实现。常见报错处理包括422 Validation Error，需检查请求格式和字段类型。</description></item><item><title>如何在FastAPI中玩转WebSocket，让实时通信不再烦恼？</title><link>https://blog.cmdragon.cn/posts/0faebb0f6c2b1bde4ba75869f4f67b76/</link><pubDate>Sun, 06 Jul 2025 20:11:20 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/0faebb0f6c2b1bde4ba75869f4f67b76/</guid><description>FastAPI 的 WebSocket 路由通过 &lt;code>@app.websocket&lt;/code> 装饰器声明，支持路径参数和查询参数验证。连接建立时需显式调用 &lt;code>websocket.accept()&lt;/code>，并通过 &lt;code>receive_text()&lt;/code> 和 &lt;code>send_text()&lt;/code> 实现双向通信。握手验证可自定义，失败时返回 403 状态码并关闭连接。连接状态可通过字典维护，心跳检测机制确保连接活跃。常见错误包括 403 握手失败、1006 非正常断开和数据类型错误，需通过正确关闭连接和数据类型处理解决。</description></item><item><title>如何在FastAPI中打造坚不可摧的安全防线？</title><link>https://blog.cmdragon.cn/posts/c74023c89591cfdffe2f392c8f3fac7a/</link><pubDate>Fri, 20 Jun 2025 11:33:15 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c74023c89591cfdffe2f392c8f3fac7a/</guid><description>FastAPI的中间件机制允许对HTTP请求和响应进行拦截处理，适用于身份认证、日志记录、流量控制等场景。通过注册中间件，可以实现IP黑名单拦截、敏感词过滤等功能。集成JWT认证和角色权限验证，确保API的安全性。常见错误如422、401、500等可通过全局异常处理器进行统一处理。最佳实践包括启用HTTPS、使用环境变量管理敏感配置、定期更新依赖库等，以构建企业级安全的API服务。</description></item><item><title>FastAPI如何用角色权限让Web应用安全又灵活？</title><link>https://blog.cmdragon.cn/posts/cc7aa0af577ae2bc0694e76886373e12/</link><pubDate>Fri, 13 Jun 2025 05:46:55 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/cc7aa0af577ae2bc0694e76886373e12/</guid><description>基于角色的路由访问控制是Web应用中常见的安全控制模式，通过为用户分配特定角色来管理权限。FastAPI利用依赖注入系统实现权限控制，具有解耦、模块化、兼容OpenAPI等优势。权限验证流程包括请求拦截、角色解析和权限校验三个阶段。通过定义数据模型和核心权限验证模块，可以实现企业级权限控制方案。常见报错如422、401、403等，可通过调试和错误处理机制解决。动态权限管理建议使用RBAC数据库结构，多角色用户可通过中间表实现。</description></item><item><title>异步日志分析：MongoDB与FastAPI的高效存储揭秘</title><link>https://blog.cmdragon.cn/posts/1963035336232d8e37bad41071f21fba/</link><pubDate>Thu, 22 May 2025 17:04:56 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/1963035336232d8e37bad41071f21fba/</guid><description>MongoDB与FastAPI集成构建日志分析系统，通过Motor驱动实现异步操作，提升数据处理效率。使用Pydantic进行数据验证，配置环境变量，创建REST API端点。聚合管道用于日志统计，如按级别分组计数。索引优化策略通过创建复合索引和文本索引，显著提升查询性能。完整案例实现错误追踪和日志搜索功能。常见报错包括422验证错误和连接超时，提供具体解决方案。课后Quiz强调索引优化、高效分页和写入可靠性。</description></item><item><title>MongoDB索引优化的艺术：从基础原理到性能调优实战</title><link>https://blog.cmdragon.cn/posts/00dab3c9b6d60d849938dede981db2c4/</link><pubDate>Wed, 21 May 2025 18:08:22 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/00dab3c9b6d60d849938dede981db2c4/</guid><description>MongoDB索引优化与性能调优的核心策略包括：索引基础原理，如单字段、复合、唯一和TTL索引；索引创建与管理，通过FastAPI集成Motor实现；查询性能优化，使用Explain分析、覆盖查询和聚合管道优化；实战案例，如电商平台订单查询优化；常见报错解决方案，如索引创建失败、查询性能下降和文档扫描过多问题。这些策略能显著提升查询速度和系统性能。</description></item><item><title>飞行中的引擎更换：生产环境数据库迁移的艺术与科学</title><link>https://blog.cmdragon.cn/posts/482d0aa759de9951348f04d49e35be14/</link><pubDate>Tue, 13 May 2025 00:06:12 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/482d0aa759de9951348f04d49e35be14/</guid><description>生产环境数据库迁移需确保数据安全性和服务持续性，强调零停机和完整回滚方案。Alembic配置优化包括禁用自动生成迁移、通过环境变量注入数据库URL，并自动生成变更校验脚本。迁移策略涉及版本控制流程和分支管理，确保每次迁移都有明确的升级和回滚路径。安全迁移实践包括蓝绿部署方案和数据一致性验证，通过创建新表、双写数据和原子切换来保障零停机。常见报错解决方案涵盖迁移锁超时、类型变更不兼容和性能下降等问题，通过配置连接池、分阶段变更类型和添加索引来应对。</description></item><item><title>多数据库迁移的艺术：Alembic在复杂环境中的精妙应用</title><link>https://blog.cmdragon.cn/posts/3bcf24764e240d3cc8f0ef128cdf59c5/</link><pubDate>Sun, 11 May 2025 00:35:52 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/3bcf24764e240d3cc8f0ef128cdf59c5/</guid><description>现代Web应用中，多数据库场景包括主从架构、多租户系统、混合数据库和分库分表。Alembic支持多数据库配置，通过创建多版本目录结构和修改alembic.ini文件实现。环境脚本（env.py）需改造以支持多数据库迁移。模型定义推荐使用pydantic结合SQLAlchemy ORM。迁移操作包括生成独立脚本、执行迁移和查看历史。常见报错如未初始化版本表、缺少数据库配置和模型类未绑定元数据，均有相应解决方案。</description></item><item><title>掌握Tortoise-ORM高级异步查询技巧</title><link>https://blog.cmdragon.cn/posts/8a980d4fc84da8b38dfc6da3b16a9818/</link><pubDate>Tue, 22 Apr 2025 12:05:33 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/8a980d4fc84da8b38dfc6da3b16a9818/</guid><description>Tortoise-ORM 提供了强大的异步查询功能，支持通过 Q 对象构建复杂查询条件，如逻辑运算符组合和动态条件构建。F 表达式用于字段级别的原子操作，避免竞争条件，适用于库存扣减和价格调整等场景。组合查询可通过注解和过滤实现复杂业务需求。常见错误包括字段不一致、未知字段和事务管理问题，需通过数据库迁移和异步上下文管理解决。</description></item><item><title>Tortoise-ORM与FastAPI集成：异步模型定义与实践</title><link>https://blog.cmdragon.cn/posts/c41e34782be5f4aa82d189539b6ae975/</link><pubDate>Sun, 20 Apr 2025 11:38:23 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c41e34782be5f4aa82d189539b6ae975/</guid><description>Tortoise-ORM通过类继承方式定义数据模型，每个模型类对应数据库中的一张表。模型字段类型与数据库类型自动映射，支持主键、唯一约束、索引等配置。模型间通过外键建立关联，支持异步查询和CRUD操作。FastAPI集成时，通过&lt;code>register_tortoise&lt;/code>初始化数据库连接，并结合Pydantic模型实现数据验证。常见错误包括字段验证失败和数据库连接超时，可通过中间件和连接池配置解决。</description></item><item><title>FastAPI数据库集成与事务管理</title><link>https://blog.cmdragon.cn/posts/0df867e01706fcb9c2e16ea07671a9e4/</link><pubDate>Fri, 18 Apr 2025 00:15:34 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/0df867e01706fcb9c2e16ea07671a9e4/</guid><description>FastAPI与SQLAlchemy集成指南：首先配置SQLite数据库连接，创建会话工厂和声明性基类。定义用户模型并映射表结构，使用Pydantic进行数据验证。通过依赖项获取数据库会话，实现用户创建和转账功能。事务控制通过显式开始事务和错误处理确保数据一致性。常见问题包括422验证错误、500服务器错误和完整性错误，需检查请求体、数据库连接和约束。课后Quiz解答事务回滚、SQL注入防护和并发写操作处理。</description></item><item><title>FastAPI与SQLAlchemy数据库集成</title><link>https://blog.cmdragon.cn/posts/c89a99dade2879f73464405270096546/</link><pubDate>Thu, 17 Apr 2025 15:33:34 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c89a99dade2879f73464405270096546/</guid><description>FastAPI与SQLAlchemy的集成通过创建虚拟环境、安装依赖、配置数据库连接、定义数据模型和实现路由来完成。核心模块包括数据库引擎、会话工厂和声明性基类。数据模型通过SQLAlchemy定义，路由通过FastAPI实现，支持创建和查询用户。测试接口通过curl命令进行，常见报错包括表不存在、请求体验证错误和会话不可用。高级配置涉及连接池优化和单元测试。</description></item><item><title>FastAPI与SQLAlchemy数据库集成与CRUD操作</title><link>https://blog.cmdragon.cn/posts/6cfb51390a424ffa1e7d9ceff121fd11/</link><pubDate>Wed, 16 Apr 2025 09:50:57 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/6cfb51390a424ffa1e7d9ceff121fd11/</guid><description>FastAPI与SQLAlchemy集成基础包括环境准备、数据库连接配置和模型定义。CRUD操作通过数据访问层封装和路由层实现，确保线程安全和事务管理。常见错误如422请求验证错误通过Pydantic模型和中间件处理。Session生命周期管理依赖注入系统保证每个请求独立会话。常见报错如数据库连接失败和事务回滚通过检查服务状态、验证连接参数和异常处理解决。</description></item><item><title>SQLAlchemy 核心概念与同步引擎配置详解</title><link>https://blog.cmdragon.cn/posts/de9dea9606a04d21ae60cbc315397580/</link><pubDate>Mon, 14 Apr 2025 00:28:46 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/de9dea9606a04d21ae60cbc315397580/</guid><description>SQLAlchemy 的核心概念包括 ORM、Engine、Connection 和 Session。ORM 将数据库表映射为 Python 类，行记录转为对象实例。Engine 管理数据库连接池，Connection 是具体连接，Session 跟踪对象状态变化。同步引擎配置涉及安装依赖、创建引擎、定义模型类及与 FastAPI 集成。连接池通过 pool_size、max_overflow 和 pool_recycle 管理连接。Session 生命周期需正确管理，避免连接泄漏和数据不一致。常见错误包括表不存在、连接池溢出和验证错误，需通过建表、调整连接池配置和请求模型验证解决。</description></item><item><title>FastAPI依赖注入性能优化策略</title><link>https://blog.cmdragon.cn/posts/80f30f46ece634f36b143b3a1fe6e82a/</link><pubDate>Sat, 12 Apr 2025 00:53:48 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/80f30f46ece634f36b143b3a1fe6e82a/</guid><description>FastAPI依赖注入机制通过将对象创建与使用分离，提升了代码的可测试性和可维护性。优化策略包括区分同步与异步依赖，异步依赖适用于I/O密集型操作；使用&lt;code>lru_cache&lt;/code>缓存依赖计算结果，减少重复计算；对数据库连接等重量级资源采用单例模式。实战案例展示了用户认证系统的优化方案，通过缓存JWT解码结果提高性能。开发环境配置和常见报错处理也提供了具体指导。</description></item><item><title>FastAPI依赖注入系统及调试技巧</title><link>https://blog.cmdragon.cn/posts/a00b68c25cfc537b46f9b263b1655fd0/</link><pubDate>Fri, 11 Apr 2025 15:00:50 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/a00b68c25cfc537b46f9b263b1655fd0/</guid><description>FastAPI的依赖注入系统采用树状结构管理依赖关系，自动解析并执行依赖项。复杂依赖关系可能导致循环依赖、性能问题、逻辑错误和调试困难。使用FastAPI内置调试接口和pydeps工具可生成依赖图，帮助可视化调试。通过重构代码打破循环依赖，使用lru_cache缓存实例，可解决常见报错如DependencyCycleError和DependencyNotInstantiableError。保持依赖树层级不超过5层，定期检查依赖结构，编写单元测试，使用类型提示，可预防问题。</description></item><item><title>FastAPI依赖注入与上下文管理</title><link>https://blog.cmdragon.cn/posts/c23af7bd8b8b6d01c7ea32c3591aa54d/</link><pubDate>Mon, 07 Apr 2025 00:28:04 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c23af7bd8b8b6d01c7ea32c3591aa54d/</guid><description>FastAPI框架依赖注入与上下文管理实战指南详细介绍了全局依赖配置、应用生命周期管理和综合应用案例。全局依赖用于统一处理认证、日志、数据库会话等跨路由逻辑，支持多层级配置。应用生命周期管理通过&lt;code>lifespan&lt;/code>事件实现资源初始化和释放。电商系统案例展示了如何结合数据库和缓存进行商品创建操作。常见报错解决方案提供了针对数据库连接、请求验证等问题的排查与预防措施。</description></item><item><title>FastAPI依赖注入：链式调用与多级参数传递</title><link>https://blog.cmdragon.cn/posts/7c1206bbcb7a5ae74ef57b3d22fae599/</link><pubDate>Sat, 05 Apr 2025 18:43:12 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/7c1206bbcb7a5ae74ef57b3d22fae599/</guid><description>FastAPI的依赖注入系统通过链式调用和多级参数传递实现组件间的解耦和复用。核心特性包括解耦性、可复用性、可测试性和声明式依赖解析。链式依赖通过多级函数调用传递参数，如电商订单处理流程中的用户认证、VIP校验和库存检查。多级参数传递模式包括垂直传递、水平聚合和动态参数传递。常见错误如422验证错误和循环引用，可通过参数验证和依赖重构解决。最佳实践包括依赖分层、参数验证、性能优化和异步支持。</description></item><item><title>FastAPI依赖注入：从基础概念到应用</title><link>https://blog.cmdragon.cn/posts/27a9080982ab01fc46bc583fd794bd24/</link><pubDate>Fri, 04 Apr 2025 16:28:51 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/27a9080982ab01fc46bc583fd794bd24/</guid><description>FastAPI的依赖注入机制通过&lt;code>Depends&lt;/code>实现，自动创建和注入依赖项，解耦组件并提高可测性。依赖项可以是函数或类，按声明顺序执行，支持同步/异步混合使用。嵌套依赖构建清晰的依赖关系树，如用户认证系统中，&lt;code>oauth2_scheme&lt;/code>提取Token，&lt;code>validate_token&lt;/code>验证有效性，&lt;code>get_user&lt;/code>获取用户信息。常见问题包括422验证错误和依赖项循环引用，可通过Pydantic模型验证和&lt;code>lambda&lt;/code>延迟解析解决。依赖项返回None会引发400错误，需注意参数默认值设置。</description></item><item><title>FastAPI中的Pydantic密码验证机制与实现</title><link>https://blog.cmdragon.cn/posts/a72a86da313f399c29b36ec08f75361d/</link><pubDate>Mon, 31 Mar 2025 00:04:51 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/a72a86da313f399c29b36ec08f75361d/</guid><description>FastAPI 中通过 Pydantic 模型实现密码验证，采用分层机制确保高效与灵活扩展。验证流程包括基础类型检查、长度验证、复杂度验证和泄露检测，任一阶段失败即终止后续验证。通过 &lt;code>SecretStr&lt;/code> 安全获取密码明文，结合正则表达式验证密码复杂度，并利用哈希函数检测密码是否泄露。模块化设计便于后续添加更多安全规则，如密码过期策略和历史密码比对。</description></item><item><title>FastAPI 核心机制：分页参数的实现与最佳实践</title><link>https://blog.cmdragon.cn/posts/8821ab1186b05252feda20836609463e/</link><pubDate>Thu, 13 Mar 2025 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/8821ab1186b05252feda20836609463e/</guid><description>在构建现代Web应用程序时，分页是一个不可或缺的功能。无论是处理大量数据还是优化用户体验，分页都起到了至关重要的作用。本文将深入探讨如何在FastAPI中实现分页参数（如page、page_size以及总页数计算），并涵盖相关的核心机制、最佳实践、常见问题及解决方案。</description></item><item><title>FastAPI 错误处理与自定义错误消息完全指南：构建健壮的 API 应用 🛠️</title><link>https://blog.cmdragon.cn/posts/cebad7a36a676e5e20b90d616b726489/</link><pubDate>Wed, 12 Mar 2025 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/cebad7a36a676e5e20b90d616b726489/</guid><description>我们将涵盖常见的错误类型、如何捕获和处理这些错误、以及如何返回自定义的错误消息。通过实例和最佳实践，您将能够有效地应对常见错误，提高 API 的鲁棒性和可维护性。此外，文章中包含课后测验和常见错误解决方案，帮助您巩固所学知识。</description></item><item><title>Nuxt.js 应用中的 error 事件钩子</title><link>https://blog.cmdragon.cn/posts/759227261e4312110b135b98dc240788/</link><pubDate>Tue, 03 Dec 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/759227261e4312110b135b98dc240788/</guid><description>在任何 Web 应用中，错误是不可避免的。无论是网络请求失败、服务器错误、还是用户输入不合法，这些错误都可能影响用户体验和应用的稳定性。为了提升恢复能力和用户体验，Nuxt.js 提供了 error 钩子，允许开发者在应用中集中处理错误，记录错误信息，并根据具体情况进行适当的处理。</description></item><item><title>应用中的错误处理概述</title><link>https://blog.cmdragon.cn/posts/10c446738808a151ce640ad92307cece/</link><pubDate>Tue, 01 Oct 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/10c446738808a151ce640ad92307cece/</guid><description>摘要：本文介绍了Nuxt中的错误处理机制，包括全局错误处理器和组件层级错误捕获，以及错误传递规则和生产环境下的处理方式</description></item><item><title>深入理解 Nuxt.js 中的 app：error：cleared 钩子</title><link>https://blog.cmdragon.cn/posts/b77d43b884a1b04d68230c5963b5e15a/</link><pubDate>Sat, 28 Sep 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/b77d43b884a1b04d68230c5963b5e15a/</guid><description>Nuxt.js 中的 app:error:cleared 钩子的用途及其实现方式。这个钩子为开发者提供了一种优雅的方式来处理错误清除后的状态恢复和用户反馈。</description></item><item><title>深入理解 Nuxt.js 中的 app：error 钩子</title><link>https://blog.cmdragon.cn/posts/cb374534e888fe4a800e013eda896737/</link><pubDate>Fri, 27 Sep 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/cb374534e888fe4a800e013eda896737/</guid><description>摘要：本文深入讲解了Nuxt.js框架中的app:error钩子，介绍其在处理web应用中致命错误的重要作用、使用方法及实际应用场景。通过创建Nuxt项目、定义插件、触发错误与测试等步骤，演示了如何利用此钩子捕获错误、记录日志及提升用户体验，最后总结其关键要点包括错误处理、友好提示及监控集成。</description></item><item><title>使用 defineNuxtRouteMiddleware 创建路由中间件</title><link>https://blog.cmdragon.cn/posts/9820edb9b255785446531ea7b1ac2269/</link><pubDate>Sat, 10 Aug 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/9820edb9b255785446531ea7b1ac2269/</guid><description>本篇文章介绍了如何使用 &lt;code>defineNuxtRouteMiddleware&lt;/code> 创建和应用路由中间件。通过示例演示了如何处理错误页面和身份验证逻辑。随着对 Nuxt.js 中间件的理解，你可以更灵活地控制应用的路由行为，从而提升用户体验。</description></item><item><title>使用 createError 创建错误对象的详细指南</title><link>https://blog.cmdragon.cn/posts/58c4afd983d5e7a26462c4830ef807b5/</link><pubDate>Thu, 08 Aug 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/58c4afd983d5e7a26462c4830ef807b5/</guid><description>摘要：本文介绍了createError函数在Nuxt应用开发中的使用方法，用于创建带有附加元数据的错误对象，以提升错误处理的灵活性和用户体验。内容包括函数参数说明、在Vue组件和API路由中的应用实例、自定义错误页面的创建、错误的捕获与处理技巧，以及如何触发致命错误展示全屏错误提示。</description></item><item><title>使用 clearError 清除已处理的错误</title><link>https://blog.cmdragon.cn/posts/c7681141b499276ec9613c76b8bdb688/</link><pubDate>Mon, 05 Aug 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/c7681141b499276ec9613c76b8bdb688/</guid><description>摘要：“文章介绍了clearError函数的作用与用法，用于清除已处理的错误并可实现页面重定向，提升用户体验。通过示例展示了在表单提交场景中如何应用此函数进行错误处理和状态管理。”</description></item><item><title>Nuxt.js 错误侦探：useError 组合函数</title><link>https://blog.cmdragon.cn/posts/b73679558bc672550fbbb72ae295fdf5/</link><pubDate>Sun, 14 Jul 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/b73679558bc672550fbbb72ae295fdf5/</guid><description>摘要：文章介绍Nuxt.js中的useError组合函数，用于统一处理客户端和服务器端的错误，提供statusCode、statusMessage和message属性，示例展示了如何在组件中使用它来捕获和显示错误信息。</description></item><item><title>Nuxt框架中内置组件详解及使用指南（四）</title><link>https://blog.cmdragon.cn/posts/9032c61e840462c63717de392173b4f5/</link><pubDate>Tue, 09 Jul 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/9032c61e840462c63717de392173b4f5/</guid><description>摘要：本文详细介绍了Nuxt 3框架中的两个内置组件：&lt;NuxtErrorBoundary>和&lt;NuxtIsland>的使用方法与示例。&lt;NuxtErrorBoundary>用于捕获并处理客户端错误，提供了错误处理和自定义错误展示的功能；而&lt;NuxtIsland>是一个实验性组件，用于渲染无客户端JavaScript的静态内容，以优化页面加载速度。文章包含组件的基本用法、配置步骤以及完整实例代码，有助于开发者高效利用这些组件提升Nuxt应用的性能与用户体验。</description></item><item><title>Nuxt框架中内置组件详解及使用指南（一）</title><link>https://blog.cmdragon.cn/posts/214c7ef07a7b90e1787f10ea626320e3/</link><pubDate>Sat, 06 Jul 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/214c7ef07a7b90e1787f10ea626320e3/</guid><description>本文详细介绍了Nuxt框架中的两个内置组件&lt;ClientOnly>和&lt;NuxtClientFallback>的使用方法与功能。&lt;ClientOnly>确保包裹的内容仅在客户端渲染，适用于处理浏览器特定功能或异步数据加载。而&lt;NuxtClientFallback>是一个实验性组件，用于在SSR过程中遇到子组件错误时，在客户端渲染备选内容，提高应用稳定性。文章通过示例代码展示了这两个组件的具体应用方式和相关属性配置。</description></item><item><title>Nuxt3 的生命周期和钩子函数（七）</title><link>https://blog.cmdragon.cn/posts/a65c336a08214aa264f38f893fd9fe64/</link><pubDate>Mon, 01 Jul 2024 00:18:53 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/a65c336a08214aa264f38f893fd9fe64/</guid><description>摘要：文章阐述了Nuxt3中Nitro生命周期钩子的使用，如nitro:config自定义配置、nitro:init注册构建钩子、nitro:build:before/after调整构建设置及处理公共资产、prerender:routes扩展预渲染路由、build:error捕获构建错误，通过示例代码指导开发者优化项目构建与部署流程。</description></item><item><title>深入理解Python多进程：从基础到实战</title><link>https://blog.cmdragon.cn/posts/e812fcfaa2f6e1e4e25715242373b47b/</link><pubDate>Mon, 29 Apr 2024 20:49:41 +0800</pubDate><guid>https://blog.cmdragon.cn/posts/e812fcfaa2f6e1e4e25715242373b47b/</guid><description>&lt;img src="https://blog.cmdragon.cn/images/2024_04_29 20_53_37.png" title="2024_04_29 20_53_37.png" alt="2024_04_29 20_53_37.png"/>
&lt;h2 id="引言">&lt;strong>引言&lt;/strong>&lt;/h2>
&lt;p>在Python编程中，多进程是一种重要的并发编程方式，可以让我们充分利用多核处理器的计算能力，实现并行处理任务，提高程序的运行效率。与多线程相比，多进程具有独立的内存空间，避免了全局解释器锁（GIL）的影响，因此更适合于CPU密集型的任务。&lt;/p></description></item></channel></rss>